#!/bin/sh

# Help constants
USAGE="usage: xeno <subcommand> [arguments]

synchronous(ish) remote file and folder editing

The most commonly used subcommands are:
  edit                  start a xeno editing session
  list                  list xeno editing sessions
  resume                resume a xeno editing session
  stop                  stop a xeno editing session
  sync                  manually synchronize a xeno editing session
  ssh                   start a xeno-aware SSH session
  config                edit xeno configuration
  daemon                start the xeno daemon

To see help information for a subcommand, use 'xeno <subcommand> --help'
"


USAGE_EDIT="usage: xeno edit [-h|--help] [[username@]hostname:[port:]]path
                 [-i|--ignore <path>]

edit locations with xeno

positional arguments:
  path_or_remote        the path to edit, either as a local path or remote
                        specification

optional arguments:
  -h, --help            show this message and exit
  -i, --ignore <path>   add an ignored remote path
"


USAGE_LIST="usage: xeno list [-h|--help]

list current xeno sessions

optional arguments:
  -h, --help            show this message and exit
"


USAGE_RESUME="usage: xeno resume [-h|--help] [-a|--all] [session]

resume an existing editing session

positional arguments:
  session               the session id to resume (see 'xeno list')

optional arguments:
  -h, --help            show this message and exit
  -a, --all             resume all sessions
"


USAGE_SYNC="usage: xeno sync [-h|--help] [-a|--all] [-f|--force] [session]

manually synchronize an editing session

positional arguments:
  session               the session id to resume (see 'xeno list')

optional arguments:
  -h, --help            show this message and exit
  -a, --all             synchronize all sessions
  -f, --force           by default, the sync command only synchronizes
                        session(s) if there are local changes - use this flag to
                        synchronize regardless of whether or not there are local
                        changes
"


USAGE_CONFIG="usage: xeno config [-h|--help] [-c|--clear] [key] [value]

view/edit xeno configuration information

positional arguments:
  key                   the configuration key to view/set/clear
  value                 the value to set for the configuration

optional arguments:
  -h, --help            show this message and exit
  -c, --clear           clear the value associated with the key
"


# xeno constants
XENO_CONFIGURATION_FILE="$HOME/.xeno.conf"
XENO_WORKING_DIRECTORY="$HOME/.xeno"
XENO_LOCAL_SESSION_DIRECTORY="$XENO_WORKING_DIRECTORY/local"
XENO_REMOTE_SESSION_DIRECTORY="$XENO_WORKING_DIRECTORY/remote"

# Check to make sure the configuration file and working directories exist
if [ ! -f "$XENO_CONFIGURATION_FILE" ]; then
  if [ -e "$XENO_CONFIGURATION_FILE" ]; then
    echo "error: configuration path exists and is not a file"
    exit 1
  fi
  touch "$XENO_CONFIGURATION_FILE"
fi
if [ ! -d "$XENO_WORKING_DIRECTORY" ]; then
  if [ -e "$XENO_WORKING_DIRECTORY" ]; then
    echo "error: working path exists and is not a directory"
    exit 1
  fi
  mkdir -p "$XENO_WORKING_DIRECTORY"
fi
if [ ! -d "$XENO_LOCAL_SESSION_DIRECTORY" ]; then
  if [ -e "$XENO_LOCAL_SESSION_DIRECTORY" ]; then
    echo "error: local sessions path exists and is not a directory"
    exit 1
  fi
  mkdir -p "$XENO_LOCAL_SESSION_DIRECTORY"
fi
if [ ! -d "$XENO_REMOTE_SESSION_DIRECTORY" ]; then
  if [ -e "$XENO_REMOTE_SESSION_DIRECTORY" ]; then
    echo "error: remote sessions path exists and is not a directory"
    exit 1
  fi
  mkdir -p "$XENO_REMOTE_SESSION_DIRECTORY"
fi


# Reads a key from the xeno configuration
# @param key The key to read
# @returns 
read_config () {
  git config --file "$XENO_CONFIGURATION_FILE" "$1"
}


# Function to launch editor
launch_editor () {
  # Try to find an appropriate editor
  core_editor=`read_config core.editor`
  if [ ! -z "$core_editor" ]; then
    eval "$core_editor" "$1"
  elif [ ! -z "$EDITOR" ]; then
    eval "$EDITOR" "$1"
  else
    echo "error: no editor specified, please set the 'core.editor' setting or" \
         "EDITOR environment variable"
  fi
}


# Function to compute canonical paths portably
canonical_path () {
  # If it's the root path, just return
  if [ "$1" = "/" ]; then
    echo "/"
    return
  fi

  # Expand tilde to home directory
  canonical_path_result=$(echo "$1" | sed 's|^~|'"$HOME|")

  # Compute the directory name
  canonical_path_dirname=$(dirname "$canonical_path_result")
  canonical_path_basename=$(basename "$canonical_path_result")

  # If the parent directory doesn't exist, abort
  if [ ! -d "$canonical_path_dirname" ]; then
    return
  fi

  # Watch out for cases of '.', which should have their basename set to ''
  if [ "$canonical_path_basename" == "." ]; then
    canonical_path_basename=""
  fi

  # If the user was at / and asked for a canonical path of '.', return '/'
  if [ "$canonical_path_dirname" = "/" -a -z "$canonical_path_basename" ]; then
    echo "/"
    return
  fi

  # Compute the full directory path
  canonical_path_dirname=$(cd "$canonical_path_dirname" && pwd)

  # Get full path
  echo "$canonical_path_dirname/$canonical_path_basename"
}


# Function to list sessions
list_sessions () {
  ls "$XENO_LOCAL_SESSION_DIRECTORY" | grep '^[0-9a-z]\{40,40\}$'
}


# Empty subcommand handler
xeno () {
  # Print usage and bail
  echo "$USAGE"
  exit 1
}


# 'edit' subcommand handler
xeno_edit () {
  # Create variables to store the ignore flags so that we can either write them
  # to file or pass them on
  ignore_lines=""
  ignore_flags=""

  # Parse arguments
  while [ $# -gt 0 ]; do
    # Grab the argument
    arg="$1"
    # Gobble up this argument
    shift
    # Check the argument value
    case "$arg" in
      -h)
        echo "$USAGE_EDIT"
        exit 0
        ;;
      --help)
        echo "$USAGE_EDIT"
        exit 0
        ;;
      -i)
        ignore_lines="${ignore_lines}${1}\n"
        ignore_flags="${ignore_flags}-i ${1} "
        shift # Gobble the ignore value
        ;;
      --ignore)
        ignore_lines="${ignore_lines}${1}\n"
        ignore_flags="${ignore_flags}-i ${1} "
        shift # Gobble the ignore value
        ;;
      *)
        if [ -z "$location" ]; then
          location="$arg"
        else
          echo "error: invalid positional argument: $arg"
          echo "$USAGE_EDIT"
          exit 1
        fi
        ;;
    esac
  done

  # Make sure a location was given
  if [ -z "$location" ]; then
    echo "error: no location specified"
    echo "$USAGE_EDIT"
    exit 1
  fi
  
  # Parse the location
  user=$(echo "$location" | grep @ | cut -d@ -f1)
  remaining=$(echo "$location" | sed s/^$user@//)
  separators=$(echo "$remaining" | sed s/[^:]//g)
  if [ "$separators" = "" ]; then
    host=""
    port=""
    path="$remaining"
  elif [ "$separators" = ":" ]; then
    host=$(echo "$remaining" | cut -d: -f1)
    port=""
    path=$(echo "$remaining" | cut -d: -f2)
  else
    host=$(echo "$remaining" | cut -d: -f1)
    port=$(echo "$remaining" | cut -d: -f2)
    path=$(echo "$remaining" | cut -d: -f3)
  fi

  # Format user and port specifications
  if [ ! -z "$user" ]; then
    user="$user@"
  fi
  if [ ! -z "$port" ]; then
    ssh_port="-p $port"
    git_port=":$port"
  fi

  # Check the type of path we're dealing with
  if [ -z "$host" ]; then
    # If it's a local path, check if we're in an SSH session or not
    if [ -z "$SSH_CONNECTION" ]; then
      # If we're not in an SSH session, then just launch our local editor
      launch_editor "$path"
    else
      # Otherwise, we're in an SSH session, so do a remote initialization

      # Create a unique session id
      session_id=$(head -c 1024 /dev/urandom | openssl dgst -sha1)

      # HACK: We use sed to strip off the "(stdin)= " prefix that some OpenSSL
      # versions spit out
      session_id=$(echo "$session_id" | sed 's/^.* //')

      # Calculate the repository path
      repository_path="$XENO_REMOTE_SESSION_DIRECTORY/$session_id"

      # Expand the path to its full canonical value
      path=$(canonical_path "$path")

      # Always use the parent directory as the work tree.  This is obviously
      # necessary in the case of files, but in the case of directories, it gives
      # us the benefit of bringing over the folder name that we are editing.
      work_tree=$(dirname "$path")

      # Determine if we're dealing with a file or directory, and update our
      # info/exclude lines appropriately.  We add rules of the following form:
      #
      # /* # Ignore all files in the root of the work tree
      # /*/ # Ignore all directories in the root of the work tree
      # !/basename or !/basename/ # Unignore the target path in the work tree
      if [ -f "$path" ]; then
        # With a file, add ignore lines for everything but the file
        ignore_lines="$ignore_lines/*\n/*/\n!/$(basename $path)\n"
      elif [ -d "$path" ]; then
        # With a directory, add ignore lines for everything but the directory
        ignore_lines="$ignore_lines/*\n/*/\n!/$(basename $path)/\n"
      else
        echo "path does not exist or is not a file or directory: $path"
        exit 1
      fi

      # Initialize the repository
      git --work-tree "$work_tree" --git-dir "$repository_path" init --quiet

      # Add our ignore files
      echo "$ignore_lines" >> "$repository_path/info/exclude"

      # Add all initial files
      $(cd "$repository_path" && git add --all "$work_tree")

      # Create the first commit
      $(cd "$repository_path" && git commit --allow-empty --quiet \
                                     --author "xeno <xeno@xeno>" -m "xeno")

      # Create the incoming branch
      $(cd "$repository_path" && git branch incoming)

      # Set up the pre-receive hook.  This will commit any changes on the remote
      # end since we will likely do a pull after pushing local changes and we
      # will want to pick these up.
      echo '#!/bin/sh
      # Add any uncommitted changes
      if [ ! -z "$(git status --porcelain)" ]; then
        git add --all "$(git config --get core.worktree)"
        git commit --quiet --author "xeno <xeno@xeno>" -m "xeno-remote"
      fi
      exit 0
      ' > "$repository_path/hooks/pre-receive"
      chmod +x "$repository_path/hooks/pre-receive"

      # Set up the post-receive hook.  This will merge the incoming branch on
      # the remote end into master, using incoming as canonical.
      # HACK: There is a --no-edit flag for merge, but it wasn't added til Git
      # 1.7.10, and before that, the editor did not pop up automatically.  The
      # GIT_MERGE_AUTOEDIT environment variable has the same effect as --no-edit
      # and will not affect older versions of Git.
      # HACK: The stupid merge command will not shut up, even with the --quiet
      # flag, so manually silence it
      echo '#!/bin/sh
      GIT_MERGE_AUTOEDIT=no git merge incoming --quiet --commit -m \
      "xeno-remote-merge" --strategy=recursive -X theirs 2>&1 > /dev/null
      exit 0
      ' > "$repository_path/hooks/post-receive"
      chmod +x "$repository_path/hooks/post-receive"
      
      # Encode the repository path
      token=$(echo "$repository_path" | openssl enc -base64 -A)

      # Spit out the initialization token
      echo "<xeno>$token</xeno>"
    fi
  else
    # If it's a remote path, we need to do remote initialization

    # Invoke xeno edit on the remote end and grab the remote repository path
    token=$(ssh $ssh_port $user$host "xeno edit $path $ignore_flags" 2>&1)

    # Check whether or not the remote xeno command worked
    if [ $? != 0 ]; then
      echo "remote error: $token"
      exit 1
    else
      # Parse the initialization token to extract the remote repository path
      repository_path=$(echo "$token" \
                        | sed 's/<xeno>\(.*\)<\/xeno>/\1/' \
                        | openssl enc -base64 -d -A)
      repository_name=$(basename "$repository_path")
    fi

    # Clone the remote repository
    git clone --quiet "$user$host$git_port:$repository_path" \
      "$XENO_LOCAL_SESSION_DIRECTORY/$repository_name"

    # Store the remote path
    git config \
        --file="$XENO_LOCAL_SESSION_DIRECTORY/$repository_name/.git/config" \
        xeno.location "$location"

    # Launch the local editor on the clone
    launch_editor $(ls "$XENO_LOCAL_SESSION_DIRECTORY/$repository_name")
  fi

  # All done
  exit 0
}


# 'list' subcommand handler
xeno_list () {
  # Parse arguments
  while [ $# -gt 0 ]; do
    # Grab the argument
    arg="$1"
    # Gobble up this argument
    shift
    # Check the argument value
    case "$arg" in
      -h)
        echo "$USAGE_LIST"
        exit 0
        ;;
      --help)
        echo "$USAGE_LIST"
        exit 0
        ;;
      *)
        echo "error: invalid argument: $arg"
        echo "$USAGE_LIST"
        exit 1
        ;;
    esac
  done

  # Loop through sessions
  session_index=1
  for s in $(list_sessions); do
    location=$(git config \
                   --file="$XENO_LOCAL_SESSION_DIRECTORY/$s/.git/config" \
                   xeno.location)
    echo "$session_index: $location"
    session_index=$((session_index + 1))
  done

  # All done
  exit 0
}


# 'resume' subcommand handler
xeno_resume () {
  # Parse arguments
  mode="single"
  while [ $# -gt 0 ]; do
    # Grab the argument
    arg="$1"
    # Gobble up this argument
    shift
    # Check the argument value
    case "$arg" in
      -h)
        echo "$USAGE_RESUME"
        exit 0
        ;;
      --help)
        echo "$USAGE_RESUME"
        exit 0
        ;;
      -a)
        mode="all" ;;
      --all)
        mode="all" ;;
      *)
        if [ -z "$session" ]; then
          session="$arg"
        else
          echo "error: invalid argument: $arg"
          echo "$USAGE_RESUME"
          exit 1
        fi
        ;;
    esac
  done

  # Make sure a session was specified
  if [ "$mode" = "single" -a -z "$session" ]; then
    echo "error: no session specified"
    echo "$USAGE_RESUME"
    exit 1
  fi

  # Loop through to find/resume the session
  session_index=1
  for s in $(list_sessions); do
    if [ "$mode" = "all" -o "$session_index" = "$session" ]; then
      # Launch the editor
      launch_editor $(ls "$XENO_LOCAL_SESSION_DIRECTORY/$s")

      # If we took care of the target session, we're done
      if [ "$mode" = "single" ]; then
        break
      fi
    fi
    session_index=$((session_index + 1))
  done

  # All done
  exit 0
}


# 'stop' subcommand handler
xeno_stop () {
  # All done
  exit 0
}


# 'sync' subcommand handler
xeno_sync () {
  # Parse arguments
  mode="single"
  while [ $# -gt 0 ]; do
    # Grab the argument
    arg="$1"
    # Gobble up this argument
    shift
    # Check the argument value
    case "$arg" in
      -h)
        echo "$USAGE_SYNC"
        exit 0
        ;;
      --help)
        echo "$USAGE_SYNC"
        exit 0
        ;;
      -a)
        mode="all" ;;
      --all)
        mode="all" ;;
      -f)
        force="force" ;;
      --force)
        force="force" ;;
      *)
        if [ -z "$session" ]; then
          session="$arg"
        else
          echo "error: invalid argument: $arg"
          echo "$USAGE_SYNC"
          exit 1
        fi
        ;;
    esac
  done

  # Make sure a session was specified
  if [ "$mode" = "single" -a -z "$session" ]; then
    echo "error: no session specified"
    echo "$USAGE_SYNC"
    exit 1
  fi

  # Loop through to find/resume the session
  session_index=1
  for s in $(list_sessions); do
    if [ "$mode" = "all" -o "$session_index" = "$session" ]; then
      # Synchronize

      # Compute the repository path
      repository_path="$XENO_LOCAL_SESSION_DIRECTORY/$s"

      # Add any local changes or create a dummy commit if we're forcing things
      uncommitted=$(cd "$repository_path" && git status --porcelain)
      if [ ! -z "$uncommitted" -o ! -z "$force" ]; then
        $(cd "$repository_path" && git add --all "$repository_path")
        $(cd "$repository_path" && git commit --allow-empty --quiet \
                                       --author "xeno <xeno@xeno>" -m "xeno")
      fi

      # If we have pending commits, push them
      unpushed=$(cd "$repository_path" && git log --pretty=oneline \
                                              --abbrev-commit \
                                              origin/master..HEAD)
      if [ ! -z "$unpushed" ]; then
        $(cd "$repository_path" && git push --quiet origin master:incoming)
        $(cd "$repository_path" && git pull --quiet --commit \
                                       --strategy recursive -X ours)
      fi

      # If we took care of the target session, we're done
      if [ "$mode" = "single" ]; then
        break
      fi
    fi
    session_index=$((session_index + 1))
  done

  # All done
  exit 0
}


# 'ssh' subcommand handler
xeno_ssh () {
  # All done
  exit 0
}


# 'config' subcommand handler
xeno_config () {
  # Parse arguments
  mode="print"
  while [ $# -gt 0 ]; do
    # Grab the argument
    arg="$1"
    # Gobble up this argument
    shift
    # Check the argument value
    case "$arg" in
      -h)
        echo "$USAGE_CONFIG"
        exit 0
        ;;
      --help)
        echo "$USAGE_CONFIG"
        exit 0
        ;;
      -c)
        mode="clear" ;;
      --clear)
        clear="clear" ;;
      *)
        if [ -z "$key" ]; then
          key="$arg"
          if [ "$mode" != "clear" ]; then
            mode="get"
          fi
        elif [ -z "$value" ]; then
          value="$arg"
          # We don't care if clear is set here, because we'll overwrite the
          # value anyway
          mode="set"
        else
          echo "error: invalid positional argument: $arg"
          echo "$USAGE_CONFIG"
          exit 1
        fi
        ;;
    esac
  done

  # Handle based on mode
  if [ "$mode" = "print" ]; then
    cat "$XENO_CONFIGURATION_FILE"
  elif [ "$mode" = "clear" ]; then
    if [ -z "$key" ]; then
      echo "error: no key specified on clear"
      echo "$USAGE_CONFIG"
      exit 1
    fi
    # NOTE: git config's --unset flag will leave empty section headers behind,
    # and when a new value for that section header is added later on, the empty
    # (and now duplicate) section header remains!  This is a known issue and has
    # been classified by the Git maintainers as "not a bug":
    # https://bugzilla.redhat.com/show_bug.cgi?id=452397
    # For now, I think we can live with it, but maybe in the future we can do
    # something fancy with sed after unsetting the key.
    git config --file "$XENO_CONFIGURATION_FILE" --unset "$key"
  elif [ "$mode" = "get" ]; then
    git config --file "$XENO_CONFIGURATION_FILE" "$key"
  elif [ "$mode" = "set" ]; then
    git config --file "$XENO_CONFIGURATION_FILE" "$key" "$value"
  fi

  # All done
  exit 0
}


# 'daemon' subcommand handler
xeno_daemon () {
  # All done
  exit 0
}


# Run the appropriate subcommand
case "$#" in
  0)
    xeno ;;
  *)
    # Grab the subcommand name
    subcommand="$1"
    # Remove the xeno argument
    shift
    # Dispatch to the appropriate subcommand
    case "$subcommand" in
      edit)
        xeno_edit "$@" ;;
      list)
        xeno_list "$@" ;;
      resume)
        xeno_resume "$@" ;;
      stop)
        xeno_stop "$@" ;;
      sync)
        xeno_sync "$@" ;;
      ssh)
        xeno_ssh "$@" ;;
      config)
        xeno_config "$@" ;;
      daemon)
        xeno_daemon "$@" ;;
      *)
        xeno ;;
    esac
esac
